#include "widget.h"

#include <QApplication>

/*
    命令模式是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传递给调用对象。调用对象寻找可以处理该命令的合适对象，并把该命令传给相应的对象，该对象执行命令。

    背景：
      在应用程序中，经常需要对相同的数据执行多个操作。可以这样简单的理解：用户有一些数据，并且界面提供了很多选项，他可以对该数据进行其中的某些操作。例如，图片处理器：
      可以选择旋转/翻转/反转照片。另外，一旦有不满意的处理，很有可能需要撤消。这就是基本的业务逻辑，必须要在实现过程中考虑清楚。

      大多情况下，最容易想到的是：当动作触发后，调用接收者对应的方法。但是这存在不少问题：
          1.要写很多条件代码，必须为每个操作编写非常类似的代码。
          2.如果有更多的命令，就会发现需要经常更改现有代码。
      显然，这种无法抵御变化的紧耦合设计不太合适。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。这就是命令模式。

         Command：定义命令的接口，声明执行的方法。
         ConcreteCommand：命令接口实现对象，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。
         Receiver：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
         Invoker：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。
         Client:创建具体命令对象，并设置其接收者（注意： 这并非常规意义上的客户端，而是在组装命令对象和接收者。或许，把这个 Client 称为装配者会更好理解，因为真正使用命令的客户端是从 Invoker 来触发执行）。


*/

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    Widget w;
    w.show();
    return a.exec();
}
