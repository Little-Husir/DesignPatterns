#include <QCoreApplication>
#include "proxy.h"

#ifndef SAFE_DELETE
#define SAFE_DELETE(p) { if(p){delete(p); (p)=NULL;} }
#endif

/*
    代理模式（Proxy Pattern）为其他对象提供了一种代理，以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，
    而代理对象可以在客户端和目标对象之间起到中介的作用。
       1.Subject（抽象主题）：声明了 RealSubject 与 Proxy 的共同接口，定义了某个/些功能。
       2.RealSubject（真实主题）：通常执行具体的业务逻辑，Proxy 控制对它的访问。
       3.Proxy（代理）：持有一个 RealSubject 引用（指针），可以在需要时将请求转发给 RealSubject，以此起到代理的作用。
       4.Client（客户端）：通过 Proxy 间接地与 RealSubject 进行交互。
    注意： Proxy 和 RealSubject 都实现了 Subject 的接口，这允许 Client 可以像处理 RealSubject 一样处理 Proxy。

    优点：
       1.代理模式能将代理对象与真正被调用的对象分离，在一定程度上降低了系统的耦合度。
       2.在客户端和目标对象之间，代理起到一个中介作用，这样可以保护目标对象。在对目标对象调用之前，代理对象也可以进行其他操作。

    缺点：
       1.这种模式引入了另一个抽象层，这有时可能是一个问题。如果真实主题被某些客户端直接访问，并且其中一些客户端可能访问代理类，这可能会导致不同的行为。
       2.由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。
       3.实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

    适用场景：
       远程代理：为一个位于不同地址空间的对象提供一个本地代理，对代理的方法调用会导致对远程对象的方法调用。ATM 就是一个例子
                ATM 可能会持有（存在于远程服务器中的）银行信息的一个代理对象。
       虚拟代理： 使用虚拟代理，代理可以作为一个（资源消耗较大的）对象的代表。虚拟代理经常延迟对象的创建，直到需要为止。在创建对象之前（及创建对象过程中）
                虚拟代理也可以作为对象的代理；之后，代理将请求直接委托给 RealSubject。
       保护代理：根据访问权限，可以使用保护代理来控制对资源的访问。例如，有一个员工对象，保护代理可以允许普通员工调用对象的某些方法，管理员调用其他方法。
       缓冲代理： 为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
       智能引用代理： 当一个对象被引用时，提供一些额外的操作（例如：将对象被调用的次数记录下来）。

    案例分析：
       中国移动-代理商
          这里，代理模式可以理解为：移动公司把充值的职责托付给代理点，代理点代替移动公司充值，客户直接与代理点打交道，而非移动公司。
*/

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    Proxy* proxy = new Proxy();
    proxy->Recharge(20);
    proxy->Recharge(100);

    SAFE_DELETE(proxy);

    getchar();

    return 0;

    return a.exec();
}
