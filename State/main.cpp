#include <QCoreApplication>
#include "context.h"
#include <iostream>
#include <windows.h>

/*
    状态模式（State Pattern）是行为设计模式之一。当对象根据其内部状态改变其行为时，将使用状态设计模式。
        Context（上下文）：定义一个与 Client 交互的接口。它维护对 ConcreteState 对象的引用，可以用该对象来定义当前状态。
        State（抽象状态）：定义接口，来声明每个 ConcreteState 应该做什么。
        ConcreteState（具体状态）：为 State 中定义的方法提供实现。

    优点:
        1.实现多态行为的好处是显而易见的，并且很容易添加状态来支持额外的行为。
        2.在状态模式中，对象的行为是其状态中函数的结果，并且在运行时根据状态改变行为，这就消除了对 switch/case或if/else条件逻辑的依赖
        3.可以提高内聚性，因为状态特定的行为被聚合到具体的类中，这些类被放在代码中的一个位置。
    缺点：
        1.使用状态模式，必然会增加系统中类和对象的个数。
        2.由于状态模式的结构与实现较为复杂，一旦使用不当，将会导致程序结构和代码的混乱。
        3.若要添加新的状态，则需要修改负责转换的源代码，否则无法转换到新增的状态，而且修改某个状态的行为也要修改源代码。

    适用场景：
        1.一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。
        2.一个系统中含有庞大的多分支结构，并且这些分支决定于对象的状态

    案例分析：
        交通信号灯的状态流：红灯 --> 绿灯 --> 黄灯。。。实际上，就是各个状态之间的相互切换，这完全符合状态模式。

    大话设计模式：
        状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。
        当然，如果这个状态判断很简单，那就没必要用'状态模式’了。

        好处：
          1.将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，即将特定的状态相关的行为都放入一个新的对象中，由于所有与状态相关的代码都存在于concrete_state中，
            所以通过定义新的子类可以很容易的增加新的状态和转换
          2.说白了，这样做的目的就是为了消除庞大的条件分支语句，大的分支判断会使得它们难以修改和扩展，就像我们最早说的刻版印刷一样，任何改动和变化都是致命的。
            状态模式通过把各种状态转移逻辑分布到 State 的子类之间，来减少相互间的依赖，好比把整个版面改成了一个又一个的活字，此时就容易维护和扩展了

        什么时候应该考虑使用状态模式呢？
            当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。另外如果业务需求某项业务有多个状态，通常都是一些枚举常量，
            状态的变化都是依靠大量的多分支判断语句来实现,此时应该考虑将每一种业务状态定义为一个 State 的子类。这样这些对象就可以不依赖于其他对象而独立变化了，
            某一天客户需要更改需求，增加或减少业务状态或改变状态流程，对系统来说都是不困难的事。

*/

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    TrafficLights tl;

    enum TLState {Red, Green, Yellow};

    TLState state = Red;  // 初始状态为红灯
    int i = 0;  // 总次数
    int seconds;  // 秒数

    while (true) {
        // 表示一个完整的状态流（红灯->绿灯->黄灯）已经完成
        if (i % 3 == 0)
            std::cout << "**********" << "Session " << ((i+1)/3)+1 << "**********" << std::endl;

        // 根据当前状态来设置持续时间，红灯（6秒）、绿灯（4秒）、黄灯（2秒）
        if (state == Red) {
            seconds = 6;
            state = Green;
        } else if (state == Green) {
            seconds = 4;
            state = Yellow;
        } else if (state == Yellow) {
            seconds = 2;
            state = Red;
        }

        // 休眠
        Sleep(seconds * 1000);

        //TrafficLights 会委托当前状态来处理行为-即设置状态为下一个灯
        tl.Request();
        i++;
    }

    return 0;

    return a.exec();
}
