#include <QCoreApplication>
#include "adapter.h"

/*
     简单来说就是做一个适配器 使原本由于接口不兼容而不能一起工作的类可以一起工作--如果能提前预防这种不兼容的问题，那么建议不使用该设计模式

    （Adapter Pattern）是一种补救模式，将一个类的接口转换成客户希望的另外一个接口，从而使原本由于接口不兼容而不能一起工作的类可以一起工作。
        Target（目标接口）：所期望得到的接口
        Adaptee（适配者）：需要适配的类
        Adapter（适配器）：该模式的核心，具有将 Adaptee 包装为 Target 的职责

     类适配器和对象适配器
        从实现层面上划分，适配器模式分为两种：
           类适配器（多继承方式）
           对象适配器（对象组合方式）

        那么，实际应用中如何在二者之间进行选择呢

           类适配器包含以下特点：
              1.由于 Adapter 直接继承自 Adaptee 类，所以，在 Adapter 类中可以对 Adaptee 类的方法进行重定义。
              2.如果在 Adaptee 中添加了一个抽象方法，那么 Adapter 也要进行相应的改动，这样就带来高耦合。
              3.如果 Adaptee 还有其它子类，而在 Adapter 中想调用 Adaptee 其它子类的方法时，使用类适配器是无法做到的。

           对象适配器包含以下特点：
              1.有的时候，你会发现，去构造一个 Adaptee 类型的对象不是很容易。
              2.当 Adaptee 中添加新的抽象方法时，Adapter 类不需要做任何调整，也能正确的进行动作。
              3.可以使用多态的方式在 Adapter 类中调用 Adaptee 类子类的方法。

           由于对象适配器的耦合度比较低，所以在很多书中都建议使用对象适配器，在实际项目中也是如此，能使用对象组合的方式，就不使用多继承的方式

     优点：                                         缺点：
        1.可以让任何两个没有关联的类一起运行                过多的使用适配器，会让系统非常凌乱，不利于整体把控
        2.提高了类的复用                              例如：
        3.增加了类的透明度                               看到调用的是 A 接口，内部却被适配成了 B 接口的实现，系统如果出现太多类似情况，
        4.灵活性好                                      无异于一场灾难。因此，如果不是很必要，可以不使用适配器，而是直接对系统进行重构。

     适用场景：
        1.当想使用一个已存在的类，而它的接口不符合需求时
        2.你想创建一个可复用的类，该类可以与其他不相关的类或不可预见的类协同工作
        3.你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它的父接口。

     案例分析
        世界各国插座标准都不尽相同，甚至同一国家的不同地区也可能不一样。例如，中国一般使用两脚扁型，而俄罗斯使用的是双脚圆形。
        那么，如果去俄罗斯旅游，就会出现一个问题：我们带去的充电器为两脚扁型，而他们提供的插座为双脚圆形，如何给手机充电呢？
        总不能为了旅客而随意更改墙上的插座吧，而且俄罗斯人一直都这么使用，并且用的很好。俗话说入乡随俗，那么只能自己想办法解决了。

        其实这个问题的解决方式很简单 - 适配器模式，只需要提供一个电源转化器即可。该转化器的一端符合俄罗斯标准，
        可以插到俄罗斯的插座上，另一端符合中国标准，可以供我们的手机充电器使用。
 */

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    // 创建适配器-即继承双脚圆形的类
    IRussiaSocket *pAdapter = new PowerAdapter();

    // 充电-即使用多态调用两脚扁形适配的Charge充电
    pAdapter->Charge();

    SAFE_DELETE(pAdapter);

    getchar();

    return 0;

    return a.exec();
}
